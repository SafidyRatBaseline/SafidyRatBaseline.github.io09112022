<!DOCTYPE html>
<html lang="en">
 
<head>

<title>MAP</title>
<meta charset="utf-8">
<link rel="stylesheet" href="css/layout.css" type="text/css" media="all">
<link rel="stylesheet" href="css/dropdown.css" type="text/css" media="all">

  <div class="body2">  
   <div class="main">
     <header>
      
        <h1><a href="#" id="logo">science</a></h1>
        

      </div>-->
      <div class="wrapper">
        
      </div>
    </header>
  </div>
</div>
    <meta charset="utf-8">
  
    <style>



      body, html { margin:0; padding:0; height:100%;}
      body { font-family:sans-serif; }
      body * { font-weight:200;}
      h1 { position:absolute; background:white; padding:10px;}
      #map { height:100%; }
      .leaflet-container {
        background: rgba(0,0,0,.8) !important;
      }
      h1 { position:absolute; background:black; color:white; padding:10px; font-weight:200; z-index:10000;}
      #all-examples-info { position:absolute; background:white; font-size:16px; padding:20px; top:100px; width:350px; line-height:150%; border:1px solid rgba(0,0,0,.2);}
    </style>
    
       <!--<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.1/dist/leaflet.css"  />-->

       
       <link rel="stylesheet" href="css/leaflet.css"  />
       <link rel="stylesheet" href="css/L.Control.Layers.Tree.css"  />
      
 
   <script src="https://unpkg.com/leaflet@1.9.1/dist/leaflet.js" integrity="sha256-NDI0K41gVbWqfkkaHj15IzU7PtMoelkzyKp8TOaFQ3s=" crossorigin=""></script>
   <script src="js/ActiveLayers.js"></script>

   <script
   type="text/javascript"
    src="https://unpkg.com/leaflet-contour@1.0.0/dist/leaflet-contour.min.js"
  ></script>

   <script src="js/SelectLayers.js"></script>
   <script src="js/L.Control.Layers.Tree.js"></script>



   <script src="js/heatmap.js"></script>
   <script src="js/leaflet-heatmap.js"></script>

   <script src="https://leaflet.calvinmetcalf.com/jam/shp/dist/shp.js"></script>
   <script src="js/proj4.js"></script>
   <script src="js/leaflet.shpfile.js"></script>

  

   <script src="js/heatmapscript/leaflet-heat.js"></script>

   <script src="https://unpkg.com/georaster-layer-for-leaflet@0.4.1/georaster-layer-for-leaflet.browserify.min.js"></script>
   <script src="https://unpkg.com/georaster-layer-for-leaflet@0.4.1/georaster-layer-for-leaflet.bundle.js"></script>
   <script src="https://unpkg.com/georaster-layer-for-leaflet@0.4.1/georaster-layer-for-leaflet.js"></script>
   <script src="https://unpkg.com/georaster-layer-for-leaflet@0.4.1/georaster.browser.bundle.js"></script>

   <script src="https://npmcdn.com/@turf/turf/turf.min.js"></script>

  <link rel="stylesheet" href="https://ppete2.github.io/Leaflet.PolylineMeasure/Leaflet.PolylineMeasure.css" />
<script src="https://ppete2.github.io/Leaflet.PolylineMeasure/Leaflet.PolylineMeasure.js"></script>

  

  
   

 


  




 
  

 


</head>

  <body>
   <h1 class="trans"  ><br><br><br><br><br>

    
 

   </h1>
   
   <div  id="map"></div>
   By Safidy.Rat

 


   <script type="text/javascript" src="./js/datareader.js"></script>

    <script>
    
///LOAD DATA






/*datacor= async () => {
  await loadcor(files[0]); 
  console.log(datacor);
};*/








/// spliting correction data
function display(){


 

 




      


var mbAttr = 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community';

var mbUrl = 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}';

var baseLayer = L.tileLayer(mbUrl, {
id: 'mapbox.streets',
attribution: mbAttr
});





      var cfg = {
        // radius should be small ONLY if scaleRadius is true (or small radius is intended)
    
        "radius":  1,
        "maxOpacity": .3,
    
        // scales the radius based on map zoom
        "scaleRadius": true, 
        // if set to false the heatmap uses the global maximum for colorization
        // if activated: uses the data maximum within the current map boundaries 
        //   (there will always be a red spot with useLocalExtremas true)
        "useLocalExtrema": false,
        // which field name in your data represents the latitude - default "lat"
        latField: 'lat',
        // which field name in your data represents the longitude - default "lng"
        lngField: 'lng',
        // which field name in your data represents the data value - default "value"
        valueField: 'count'
      };

      console.log(cfg);


      var cfg2 = {
       

        "gradient": {
            0.85: 'blue',
            0.92:"green",
            0.98: 'yellow',
            1: 'red'
        },

        
        // radius should be small ONLY if scaleRadius is true (or small radius is intended)
        "radius":0.5,
        "maxOpacity": .3, 








        
    
        // scales the radius based on map zoom
        "scaleRadius":true, 
        // if set to false the heatmap uses the global maximum for colorization
        // if activated: uses the data maximum within the current map boundaries 
        //   (there will always be a red spot with useLocalExtremas true)
        "useLocalExtrema":true,
      
       

     
        // which field name in your data represents the latitude - default "lat"
        latField: 'lat',
        // which field name in your data represents the longitude - default "lng"
        lngField: 'lng',
        // which field name in your data represents the data value - default "value"
        valueField: 'count'
      };

    

      var cfg3 = {
        "gradient": {
            0.85: 'blue',
            0.92:"green",
            0.98: 'yellow',
            1: 'red'
        },
        // radius should be small ONLY if scaleRadius is true (or small radius is intended)
        "radius": 0.05,
        "maxOpacity": 0.4, 
        // scales the radius based on map zoom
        "scaleRadius": true, 
        // if set to false the heatmap uses the global maximum for colorization
        // if activated: uses the data maximum within the current map boundaries 
        //   (there will always be a red spot with useLocalExtremas true)
        "useLocalExtrema": true,
        // which field name in your data represents the latitude - default "lat"
        latField: 'lat',
        // which field name in your data represents the longitude - default "lng"
        lngField: 'lng',
        // which field name in your data represents the data value - default "value"
        valueField: 'count',
      
      };


      var heatmapLayer3 = new HeatmapOverlay(cfg3);
       heatmapLayer3.setData(testData[2]);

      /*var heatmapLayer2 = new HeatmapOverlay(cfg2);
       heatmapLayer2.setData(testData[1]);*/

       console.log(heatmapLayer2);






      var heatmapLayer = new HeatmapOverlay(cfg);
      heatmapLayer.setData(testData[0]);


      var center = [37.78791180770003, -122.40962505340575];

/*
      var map = new L.Map('map', {
        center: new L.LatLng(-19.5, 44),
        zoom: 6,
        layers: baseLayer
      });*/

      var map = new L.Map('map', {
        center: new L.LatLng(-19.5, 44),
        zoom: 6,
        layers: baseLayer
      });



   

      //////////////////////////////////////////////////


/////measur
L.control.polylineMeasure({unit: 'miles'}).addTo(map);





///////////////////////////////////////////TURF/////////////////////////////////////////////////

// Creat Bufffffre////////////////////////////////////////////////////
console.log(Longpb)
var Pbp=[];
for(let h=0; h<=76;h++){
 
  var latln=[Longpb[h],Latpb[h]];
  Pbp.push(latln);
}
console.log( Pbp);

var line = {
  "type": "Feature",
  "properties": {
    "color": "blue"
  },
  "geometry": {
    "type": "LineString",
    "coordinates": Pbp
    /*[
      [-122.40447521209718,
        37.79367718768535
      ],
      [-122.40803718566895,
        37.79171022624846
      ],
      [-122.40769386291502,
        37.79096412372944
      ],
      [-122.40662097930908,
        37.789641468930114
      ],
      [-122.40941047668457,
        37.789675383451495
      ],
      [-122.40992546081543,
        37.78875968591083
      ],
      [-122.40962505340575,
        37.78791180770003
      ]
    ]*/
  }
};



var poly1=L.geoJSON(line, {
  style: function(feature) {
    return {
      color: feature.properties.color
    };
  }
}).addTo(map);

var polygon = turf.buffer(line, 0.015, {
  units: 'kilometres',
  steps: 15
});

console.log(polygon.geometry.coordinates);

var poly2=L.geoJSON(polygon, {
  style: function(feature) {
    return {
      color: feature.properties.color
    };
  }
}).addTo(map);
//.addTo(map)

//////turf difference///////////////////////////////////////////////////
Pbp.push(Pbp[0]);
var polygon1 = turf.polygon([Pbp], {
  "fill": "#F00",
  "fill-opacity": 0.1
});
var buffpoint=polygon.geometry.coordinates[0];
buffpoint.push(buffpoint[0]);

console.log(buffpoint[0]);

var polygon2 = turf.polygon([buffpoint], {
  "fill": "#00F",
  "fill-opacity": 0.1
});


var difference = turf.difference(polygon2, polygon1);



//var difference = turf.difference(polygon, line);
var diff=L.geoJSON(difference, {
  style: function(feature) {
    return {
      color: "#00F"
    };
  }
}).addTo(map);
//difference.addTo(map);

////ile//////////////////////////////////////////////////////////
    var il="./geoid/iles.zip";
var shapfile_iles = new L.Shapefile(il, {         
style: {
    "color": "#000000",
    "fill": "none",
    "weight": 2
  },

 
  
  onEachFeature: function(feature, layer) {
    layer.bindPopup(feature.properties.Nom, {permanent: true, opacity: 0.5}).openTooltip();
  

    if (feature.properties && feature.properties.name) {

           
            label = String(feature.properties.name);

        
            //layer.bindPopup(feature.properties.name).openTooltip();
            var element = document.getElementById(".leaflet-tooltip");
            console.log("all"  );
            //element.classList.remove("background-color");

            layer.bindPopup("layer.feature.properties.name", {permanent: true, opacity: 5}).openTooltip();

            //layer.bindPopup(layer.feature.properties.Nom).openPopup();
            //layer.bindPopup(layer.feature.properties.Nom, {permanent: true, opacity: 5});
           
            //layer.bindTooltip("<h4>"+feature.properties.name+"</h4>", {permanent: true, opacity: 5});
            //layer.bindPopup(layer.feature.properties.name);


        }


        ///push new tree

        



      }

  
});

shapfile_iles.addTo(map);


/////Actuelle ZE
var ZE='./geoid/eez.zip'
var shapfile_ze = new L.Shapefile(ZE, {         
style: {
    "color": "#000000",
    "fill": "none",
    "weight": 2
  },

 
  
  onEachFeature: function(feature, layer) {
    layer.bindPopup("ZEE", {permanent: true, opacity: 0.5}).openTooltip();
  

    if (feature.properties && feature.properties.name) {

           
            label = String(feature.properties.name);

        
            //layer.bindPopup(feature.properties.name).openTooltip();
            var element = document.getElementById(".leaflet-tooltip");
            console.log("all"  );
            //element.classList.remove("background-color");

            layer.bindPopup("layer.feature.properties.name", {permanent: false, opacity: 0.5}).openTooltip();

            //layer.bindPopup(layer.feature.properties.Nom).openPopup();
            //layer.bindPopup(layer.feature.properties.Nom, {permanent: true, opacity: 5});
           
            //layer.bindTooltip("<h4>"+feature.properties.name+"</h4>", {permanent: true, opacity: 5});
            //layer.bindPopup(layer.feature.properties.name);


        }


        ///push new tree

        



      }

  
});

shapfile_ze.addTo(map);

///////////PB/////////////////////////////



var Pb_final='./geoid/pb_final.zip'
var shapfile_pb = new L.Shapefile(Pb_final, {         
style: {
    "color": "#000000",
    "fill": "none",
    "weight": 2
  },

 
  
  onEachFeature: function(feature, layer) {
    layer.bindPopup(layer.feature.properties.name, {permanent: true, opacity: 0.5}).openTooltip();
    

      }

  
});

shapfile_pb.addTo(map);

    
  
    
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
     

             ///show value

    var command3 = L.control({position: 'topleft'});

    command3.onAdd = function (map) {
    var div = L.DomUtil.create('div');
    div.innerHTML = `
    <div id="tooltip" value="test overlapping"> </div>`; 
    return div;
        
};
command3.addTo(map);

var tooltip = document.querySelector('#tooltip');

function updateTooltip(x, y, display_val) {
  // + 15 for distance to cursor
  var transl = 'translate(' + (x ) + 'px, ' + (y ) + 'px)';
  tooltip.style.webkitTransform = transl;
  tooltip.innerHTML = display_val;
};



//map.createPane('heatPane');
//heatmapLayer2['overlayPane'] = 'heatPane';

/*
var heatPane = map.getPanes('heatPane').overlayPane; // access the canvas
// now, use mousemove on pane; the leaflet map.on("mousemove", function (e){}) won't help
heatPane.onmousemove = function (e) { 
  var x = e.layerX;
  var y = e.layerY;
var display_val = heatmapLayer2._heatmap.getValueAt({
    x: x,
    y: y
});




console.log(display_val);
 // display wherever you like the 'display_val' parameter, either as tooltip or in a div
 //tooltip.style.display = 'block';
  updateTooltip(x, y, display_val);

};
*/


     
  

      // make accessible for debugging
      layer = heatmapLayer;





      ///////LAYERS

      var osmbaseLayer = L.tileLayer(
        'http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{
          attribution: 'Map data &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors, <a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery © <a href="http://cloudmade.com">CloudMade</a>',
          maxZoom: 18
        }
      );

  

      var baseTree =
             [
                {
                    label: 'BASEMAP',
                    //layer: osmbaseLayer,
                    children: [
                        {label: 'openStreeMap', layer: osmbaseLayer, name: 'OpenStreeMap'},
                        {label: 'Esri satellite Map', layer: baseLayer, name: 'Esri satellite Map'},
                    ]
                },
                
            ];

            var baseTree2 =
             [
                {
                  layer: osmbaseLayer,
                   
                    children: [
                        
                    ]
                },
                
            ];
     


        var ctl = L.control.layers.tree(baseTree, null,
            {
                namedToggle: true,
                //collapseAll: 'Collapse all',
                //expandAll: 'Expand all',
                collapsed: false,
            });

  //ctl.addTo(map).collapseTree().expandSelected(); 
  
  var hasAllUnSelected = function() {
            return function(ev, domNode, treeNode, map) {
                var anySelected = false;
                function iterate(node)
                {
                    if (node.layer && !node.radioGroup) {
                        anySelected = anySelected || map.hasLayer(node.layer);
                    }
                    if (node.children && !anySelected) {
                        node.children.forEach(function(element) { iterate(element); });
                    }
                }
                iterate(treeNode);
                return !anySelected;
            };
        };
            
            
            
            

  /////Data overlay

  var overlaysTree =[ {
            label: 'Couche vecteur et raster',
            selectAllCheckbox: 'Un/select all',
            children: [
                {label: '<div id="onlysel">-Choisir affiché ou pas-</div>'},
                {label: 'ZEE', layer:shapfile_ze },
                {label: 'Iles autours', layer:shapfile_iles},
                {label: 'Point de Base', layer:shapfile_pb},
                {label: 'Ligne de Base', layer:poly1},
                {label: 'Insertitude (15 metres)', layer:poly2 }, 
                
            ]
        },

      
      ];

        var lay = L.control.layers.tree(baseTree, overlaysTree,
            {
                namedToggle: true,
                selectorBack: false,
                closedSymbol: '&#8862; &#x1f5c0;',
                openedSymbol: '&#8863; &#x1f5c1;',
                //collapseAll: 'Collapse all',
                //expandAll: 'Expand all',
                collapsed: false,
            });

            lay.addTo(map).collapseTree().expandSelected().collapseTree(true);
        L.DomEvent.on(L.DomUtil.get('onlysel'), 'click', function() {
            lay.collapseTree(true).expandSelected(true);
        });



  //////////////////



/*if(control._activeOverlayLayers.name=='Clouds2'){


  console.log("okookokokokok:"+ control._activeOverlayLayers.name);
}
*/





      // Creating a marker
      /*
      var marker=[]
      for(let i=0; i<=datacor.length-3;i++){

        marker[i] = new L.Marker([Latcor[i], Longcor[i]]);
         // Adding popup to the marker
         Cor[i]=Cor[i]-2.505;
         marker[i].bindPopup( locName[i]+": "+ Cor[i]+ " m").openPopup();

        marker[i].addTo(map);
      

      }

      console.log(locName);*/


      var command = L.control({position: 'topright'});
      var command2 = L.control({position: 'topleft'});

      function load_home() {
     document.getElementById("command2").innerHTML='<object type="text/html" data="Madamap2.html" ></object>';
}

///printer IMG



///////////////


command.onAdd = function (map) {
    var div = L.DomUtil.create('div');
    div.innerHTML = `
    <div >
      
      <input type="file" id="file-selector" accept=".zip" style="display: none;" />
      <input type="button" class="styled" value="Load ziped shapefile" onclick="document.getElementById('file-selector').click();" /><br><br>

      <input type="file" id="file-selector2" accept=".tif" style="display: none;" />
      <input type="button" class="styled" value="Load raster file" onclick="document.getElementById('file-selector2').click();" />

 
    </div>`; 
    return div;

    
    document.getElementById("command1").checked = true;
        
};
command.addTo(map);

      
 


///file loader
var contents="";
var contents2="";
var atribute=[];

var longb=[];
var latb=[];
var name=[];
var i=0;

var markerArray = [];
 var markerLocation;

 var rasterfirstload=0;
 var vectorfirstload=0;
 var first="";

///geotiff load

document.getElementById("file-selector2").addEventListener("change", function(event) {
        var file = event.target.files[0];
        console.log("file:", file);

        var reader = new FileReader();
        reader.readAsArrayBuffer(file);
        reader.onloadend = function() {
          var arrayBuffer = reader.result;
          parseGeoraster(arrayBuffer).then(georaster => {

            console.log("georaster:", georaster);
            /*
                GeoRasterLayer is an extension of GridLayer,
                which means can use GridLayer options like opacity.
                Just make sure to include the georaster option!
                http://leafletjs.com/reference-1.2.0.html#gridlayer
            */
            var layer = new GeoRasterLayer({
                georaster: georaster,
                opacity: 25,
          
               
               
                resolution: 250 // optional parameter for adjusting display resolution
            });
      
            map.fitBounds(layer.getBounds());
            layer.setZIndex(10);
            layer.addTo(map);

            ///push new tree

            if (rasterfirstload==0)
            {

              var rasterTree =
            {
              label: 'Raster Layers',
            selectAllCheckbox: 'Un/select all',
            children: [

            {label: file.name, layer: layer },
    
              ]
        }

        overlaysTree.push(rasterTree);
        rasterfirstload=1;

        if(first ==""){
          first="raster";
        }
        


            }


            else{

        if(first=="raster"){
          var objchild={label: file.name, layer: layer };
          overlaysTree[1].children.push(objchild);
          console.log(overlaysTree[1].children);
        }

        if(first=="vector"){
          var objchild={label: file.name, layer: layer };
          overlaysTree[2].children.push(objchild);
          console.log(overlaysTree[2].label);
        }
       

          }


            


  

           lay.setOverlayTree(overlaysTree);
          


       
          });
        };
      });


////shp load




  const fileSelector = document.getElementById('file-selector');
  fileSelector.addEventListener('change', (event) => {
    const fileList = event.target.files[0];
    var reader = new FileReader(); 
    reader.onload = function(event) { 
        console.log(event.target.result);
       contents = event.target.result;


        var shapfile = new L.Shapefile(contents, {      
          
          style: {
    "color": "#000000",
    "fill": "none",
    "weight": 2
  },

 
  
  onEachFeature: function(feature, layer) {

  

    if (feature.properties && feature.properties.name) {

           
            label = String(feature.properties.name);

        
            //layer.bindPopup(feature.properties.name).openTooltip();
            var element = document.getElementById(".leaflet-tooltip");
            console.log("all"  );
            //element.classList.remove("background-color");


            layer.bindPopup(layer.feature.properties.name, {permanent: true, opacity: 5}).openTooltip();
           
            //layer.bindTooltip("<h4>"+feature.properties.name+"</h4>", {permanent: true, opacity: 5});
            //layer.bindPopup(layer.feature.properties.name);


        }


        ///push new tree

        



      }

  
});








  

    shapfile.addTo(map);




  

    if (vectorfirstload==0)
            {

              var rasterTree =
            {
              label: 'Vector Layers',
            selectAllCheckbox: 'Un/select all',
            children: [

            {label: fileList.name, layer: shapfile },
    
              ]
        }

        overlaysTree.push(rasterTree);
        vectorfirstload=1;

        if(first ==""){
          first="vector";
        }
        


            }


            else{

        if(first=="vector"){
          var objchild={label: fileList.name, layer: shapfile };
          overlaysTree[1].children.push(objchild);
          console.log(overlaysTree[1].children);
        }

        if(first=="raster"){
          var objchild={label: fileList.name, layer: shapfile };
          overlaysTree[2].children.push(objchild);
          console.log(overlaysTree[2].label);
        }
       

          }



           lay.setOverlayTree(overlaysTree);


    var long= longb;
    var lat= latb;


  const t= shapfile.addTo(map);

  if(t==null){
    console.log("LOAD ZIP FILE");
  }
    }; 

reader.readAsArrayBuffer(fileList);

/// attribue

var userPolygon;

  for (var f in layer._layers) {
                var feature = layer._layers[f];
              }
  
            
      
    //reader.readAsDataURL(fileList); 

  
    
    //console.log(fileList);

    //for the shapefiles in the folder called 'files' with the name pandr.shp


  });


      
 


}

loadcor();





    </script>
  </body>
</html>